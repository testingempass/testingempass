package com.empass.sdk.activity;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.os.Bundle;
import android.os.CountDownTimer;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.Message;
import android.text.Html;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.empass.sdk.R;
import com.empass.sdk.db.SDKDBHelper;
import com.empass.sdk.main.EmpassActivity;
import com.empass.sdk.s2.AnswerTimeResponse;
import com.empass.sdk.s2.ApiQuestion;
import com.empass.sdk.s2.FinalResult;
import com.empass.sdk.s2.WarpCallbackMessageCode;
import com.empass.sdk.s2.WarpGameNotifyListener;
import com.empass.sdk.s2.WarpResponseCode;
import com.empass.sdk.s2.WarpUpdateRequestListener;
import com.empass.sdk.utils.AbstractBEJsonParser;
import com.empass.sdk.utils.CircleTransform;
import com.empass.sdk.utils.LogUtils;
import com.empass.sdk.vo.Goal;
import com.empass.sdk.vo.OpponentVO;
import com.empass.sdk.vo.User;
import com.empass.sdk.vo.UserOption;
import com.empass.sdk.vo.UserQuestionVO;
import com.shephertz.app42.gaming.multiplayer.client.WarpClient;
import com.squareup.picasso.Picasso;

import java.util.ArrayList;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;


/***
 * Game Activity is use to Playing game
 *
 * @author Deepak
 */
@SuppressWarnings("ALL")
public class GameActivity extends EmpassActivity {
    /***
     * Initialize OpponentUser
     */
    private static OpponentVO opponentUser;
    /***
     * Initialize WarpClient
     */
    private static WarpClient warpClient;
    /***
     * Initialize questionId
     */
    private transient String questionId;
    /***
     * Initialize currentPlayer
     */
    private static String currentPlayer;
    /***
     * Initialize Button
     */
    public transient TextView btnOption1;
    /***
     * Initialize Button
     */
    public transient TextView btnOption2;
    /***
     * Initialize Button
     */
    public transient TextView btnOption3;
    /***
     * Initialize Button
     */
    public transient TextView btnOption4;
    /**
     * Initialize boolean
     */
    private transient final AtomicInteger questionCount = new AtomicInteger(0);
    /**
     * Initialize boolean
     */
    private transient final AtomicBoolean isGetQuestion = new AtomicBoolean(true);
    /**
     * declare variable
     */
    private transient final AtomicBoolean isFirstQue = new AtomicBoolean(true);
    /**
     * Initialize boolean
     */
    private transient final AtomicBoolean isLastQue = new AtomicBoolean(false);
    /**
     * Initialize boolean
     */
    private transient final AtomicBoolean isAbandoned = new AtomicBoolean(false);
    /**
     * Initialize time
     */
    private transient long responseTime;
    /**
     * Initialize BEGameCountDownTimer
     */
    private static BEGameCountDownTimer countDownTimer;
    /**
     * Initialize BEBeforeOptionCountDownTimer
     */
    private static BEBeforeOptionCountDownTimer beforeOCounter;
    /**
     * Initialize BEBeforeQuestionCountDownTimer
     */
    private static BEBeforeQuestionCountDownTimer beforeQCounter;

    /**
     * Initialize optionStartTime
     */
    private static final long OPTIONTIME = 3000;
    /**
     * Initialize questionStartTime
     */
    private static final long QUESTIONTIME = 5000;
    /**
     * Initialize interval
     */
    private static final long INTERVEL = 1000;
    /**
     * Initialize answerGiven
     */
    private transient final AtomicBoolean answerGiven = new AtomicBoolean(false);
    /**
     *
     */
    private transient final AtomicBoolean dialog = new AtomicBoolean(false);
    /**
     * Initialize ImageView
     */
    public transient ImageView watchImage;
    /**
     * declare variable
     */
    public transient ImageView leftImage1;
    /**
     * declare variable
     */
    public transient ImageView leftImage2;
    /**
     * declare variable
     */
    public transient ImageView leftImage3;
    /**
     * declare variable
     */
    public transient ImageView leftImage4;
    /**
     * declare variable
     */
    public transient ImageView leftImage5;
    /**
     * declare variable
     */
    public transient ImageView leftImage6;
    /**
     * declare variable
     */
    public transient ImageView leftImage7;
    /**
     * declare variable
     */
    public transient ImageView leftImage8;
    /**
     * declare variable
     */
    public transient ImageView leftImage9;
    /**
     * declare variable
     */
    public transient ImageView leftImage10;
    /**
     * declare variable
     */
    public transient ImageView rightImage1;
    /**
     * declare variable
     */
    public transient ImageView rightImage2;
    /**
     * declare variable
     */
    public transient ImageView rightImage3;
    /**
     * declare variable
     */
    public transient ImageView rightImage4;
    /**
     * declare variable
     */
    public transient ImageView rightImage5;
    /**
     * declare variable
     */
    public transient ImageView rightImage6;
    /**
     * declare variable
     */
    public transient ImageView rightImage7;
    /**
     * declare variable
     */
    public transient ImageView rightImage8;
    /**
     * declare variable
     */
    public transient ImageView rightImage9;
    /**
     * declare variable
     */
    public transient ImageView rightImage10;
    /**
     * declare variable
     */
    public transient TextView txtQuestionNo;
    /**
     * declare variable
     */
    public transient TextView txtQuestion;
    /**
     * declare variable
     */
    public transient TextView playerSkill;

    /**
     * Initialize ImageView
     */
    private static ImageView[] leftRing, rightWhiteRing, rightGreenRing;
    /**
     * Initialize Option
     */
    public transient TextView[] optionButton;
    /**
     * Initialize Option
     */
    public transient ImageView[] optionImage;
    /**
     * declare variable
     */
    public transient LinearLayout linearQuestion;
    /**
     * declare variable
     */
    public transient TextView txtUserName;
    /**
     * declare variable
     */
    public transient TextView txtOppName;
    /**
     * declare variable
     */
    public transient TextView tvUserLetters;
    /**
     * declare variable
     */
    public transient ImageView ivPlayerimage;
    /**
     * declare variable
     */
    public transient TextView tvOppLetters;
    /**
     * declare variable
     */
    public transient ImageView ivOppimage;
    /**
     * declare variable
     */
    public transient ImageView userBadge;
    /**
     * declare variable
     */
    public transient ImageView userCountryFlag;
    /**
     * declare variable
     */
    public transient ImageView imgOption1;
    /**
     * declare variable
     */
    public transient ImageView imgOption2;
    /**
     * declare variable
     */
    public transient ImageView imgOption3;
    /**
     * declare variable
     */
    public transient ImageView imgOption4;
    /**
     * declare variable
     */
    public transient ImageView oppBadge;
    /**
     * declare variable
     */
    public transient ImageView oppCountryFlag;
    /**
     * Initialize WarpGameNotifyListener
     */
    private static WarpGameNotifyListener warpgListener;
    /**
     * Initialize WarpUpdateRequestListener
     */
    private static WarpUpdateRequestListener warpUListener;
    /**
     * Initialize apiQuestion
     */
    private static ApiQuestion apiQuestion;
    /**
     * declare variable
     */
    public transient Goal goals;
    /**
     * declare variable
     */
    public transient int intervel, max;
    /**
     * declare variable
     */
    public transient int myAnsIndex;
    /**
     * declare variable
     */
    public transient int countForImage;
    /**
     * declare variable
     */
    public transient int totalImageCount;
    /**
     * declare variable
     */
    protected static transient ProgressDialog progressDialogs;
    public transient User player;
    public transient Goal goal;
    public transient Intent intent;

    /**
     * Initialize GameActivity
     */
    public GameActivity() {
        super();
    }

    /**
     * Initialize BEBeforeQuestionCountDownTimer
     */
    public class BEBeforeQuestionCountDownTimer extends CountDownTimer {
        /**
         * ProgressDialog
         */
        private transient ProgressDialog progressSending = new ProgressDialog(context);

        /**
         * Initialize BEBeforeQuestionCountDownTimer
         */
        public BEBeforeQuestionCountDownTimer(final long optionStartTime, final long interval) {

            super(optionStartTime, interval);
        }

        /**
         * Initialize onFinish
         */
        @Override
        public void onFinish() {
            LogUtils.debug(sdkConstant.TAG, "BEBeforeQuestionCountDownTimer Finish start");
            try {
                LogUtils.debug(sdkConstant.TAG, "Stop Dialog");
                progressSending.dismiss();
                dialog.set(true);
                displayQuestionAndOption(apiQuestion, "Q");
            } catch (Exception e) {
                LogUtils.error(sdkConstant.TAG, "Error while onFinish", e);
            }
            LogUtils.debug(sdkConstant.TAG, "BEBeforeQuestionCountDownTimer Finish stop");
        }

        /**
         * Initialize onTick
         */
        @Override
        public void onTick(final long count) {
            try {
                final int timeElapsed = 5 - (int) (count / 1000);
                LogUtils.debug(sdkConstant.TAG, "Tick Before Question:" + timeElapsed);
                /**
                 * first question
                 */
                if (isFirstQue.get()) {
                    dialog.set(true);
                    if (dialog.get()) {
                        LogUtils.debug(sdkConstant.TAG, "Start Dialog");
                        progressSending = ProgressDialog.show(context, "", "", true);
                        progressSending.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
                        progressSending.setContentView(R.layout.next_question_progress);
                        final TextView tvPro = (TextView) progressSending.findViewById(R.id.tv_prog);
                        tvPro.setText(R.string.m_get_ready);
                        dialog.set(false);
                    }
                    isFirstQue.set(false);
                }
                /**
                 * show dialog after 4 sec
                 */
                if (!isFirstQue.get() && s2Constant.FOUR == timeElapsed && dialog.get()) {
                    LogUtils.debug(sdkConstant.TAG, "Start Dialog");
                    progressSending = ProgressDialog.show(context, "", "", true);
                    progressSending.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
                    progressSending.setContentView(R.layout.next_question_progress);
                    final TextView tvPro = (TextView) progressSending.findViewById(R.id.tv_prog);
                    tvPro.setText(R.string.m_next_question);
                    dialog.set(false);
                }
            } catch (Exception e) {
                LogUtils.error(sdkConstant.TAG, "Exception", e);
            }
        }
    }

    /**
     * Initialize BEBeforeOptionCountDownTimer
     */
    public class BEBeforeOptionCountDownTimer extends CountDownTimer {
        /**
         * Initialize OpponentUser
         */
        public BEBeforeOptionCountDownTimer(final long optionStartTime, final long interval) {
            super(optionStartTime, interval);
        }

        /**
         * Initialize onFinish
         */
        @Override
        public void onFinish() {
            LogUtils.debug(sdkConstant.TAG, "BEBeforeOptionCountDownTimer Finish start");
            try {
                /**
                 * last question
                 */
                if (isLastQue.get()) {
                    callResultActivity();
                } else {
                    /**
                     * question not last
                     */
                    LogUtils.debug(sdkConstant.TAG, "display option");
                    displayQuestionAndOption(apiQuestion, "O");
                }
            } catch (Exception e) {
                LogUtils.error(sdkConstant.TAG, "Exception", e);
            }
            LogUtils.debug(sdkConstant.TAG, "BEBeforeOptionCountDownTimer Finish stop");
        }

        /**
         * Initialize onTick
         */
        @Override
        public void onTick(final long count) {
            LogUtils.debug(sdkConstant.TAG, "display option tick");
        }
    }

    /**
     * BECountDownTimer is use to display watch and user and opponent ring
     */
    public class BEGameCountDownTimer extends CountDownTimer {
        /**
         * Initialize BEGameCountDownTimer
         */
        public BEGameCountDownTimer(final long startTime, final long interval) {
            super(startTime, interval);
        }

        /**
         * Initialize onFinish
         */
        @Override
        public void onFinish() {
            LogUtils.debug(sdkConstant.TAG, "BECountDownTimer onFinish start");
            try {
                //user no give answer in 10 sec then give no answer
                watchImage.setImageResource(sdkCommonUtils.getImageResource(context, s2Constant.TIMER_PATH + 10));
                rightWhiteRing[9].setImageResource(R.drawable.timerwave_right_a);
                if (!answerGiven.get()) {
                    responseTime = 10;
                    LogUtils.debug(sdkConstant.TAG, "No Answer");
                    leftRing[9].setImageResource(R.drawable.timerwave_left_a);
                    sendAnswerToServer(s2Constant.NO_ANSWER);
                }
            } catch (Exception e) {
                LogUtils.error(sdkConstant.TAG, "Exception", e);
            }
            LogUtils.debug(sdkConstant.TAG, "BECountDownTimer onFinish stop");
        }

        /**
         * Initialize onTick
         */
        @Override
        public void onTick(final long count) {
            LogUtils.debug(sdkConstant.TAG, "BECountDownTimer onTick start");
            try {
                int timeElapsed = max - (int) (count / 1000);
                timeElapsed = (timeElapsed * 10) / max;
                if (1000 != intervel) {
                    timeElapsed = timeElapsed + 1;
                }
                responseTime = timeElapsed;
                watchImage.setImageResource(sdkCommonUtils.getImageResource(context, s2Constant.TIMER_PATH + timeElapsed));
                // check if player answer then get the time else down the ring
                if (timeElapsed > 0) {
                    if (!answerGiven.get()) {
                        leftRing[timeElapsed - 1].setImageResource(R.drawable.timerwave_left_a);
                    }
                    rightWhiteRing[timeElapsed - 1].setImageResource(R.drawable.timerwave_right_a);
                } else {
                    if (!answerGiven.get()) {
                        leftRing[0].setImageResource(R.drawable.timerwave_left_a);
                    }
                    rightWhiteRing[0].setImageResource(R.drawable.timerwave_right_a);
                }
            } catch (Exception e) {
                LogUtils.error(sdkConstant.TAG, "Exception", e);
            }
            LogUtils.debug(sdkConstant.TAG, "BECountDownTimer onTick stop");
        }
    }

    /**
     * callback of WarpNotifyListener
     */

    public transient Callback warpCallBack = new Callback() {
        /**
         * handleMessage
         */
        @Override
        public boolean handleMessage(final Message msg) {
            switch (msg.what) {
                //callback of question receive
                case WarpCallbackMessageCode.MSG_QUE_REC:
                    LogUtils.debug(sdkConstant.TAG, "MSG_QUESTION_RECEIVED");
                    //get question vo
                    apiQuestion = (ApiQuestion) msg.obj;
                    if (apiQuestion != null && isGetQuestion.get()) {
                        // question vo is not null then display question
                        isGetQuestion.set(false);
                        beforeQCounter.start();
                    }

                    break;
                //callback of update current question answer with opponent answer and right answer
                case WarpCallbackMessageCode.MSG_ANS_REC:
                    LogUtils.debug(sdkConstant.TAG, "MSG_ANSWER_RECEIVE");
                    //parse updateAnswerResponse in vo
                    final AnswerTimeResponse[] timeResponse = (AnswerTimeResponse[]) msg.obj;
                    if (timeResponse != null) {
                        //answerTimeResponse vo is not null then update answers with scores
                        showAnswerAndScore(timeResponse);
                    }
                    break;
                //callback of final result
                case WarpCallbackMessageCode.MSG_FINAL_RESULT:
                    LogUtils.debug(sdkConstant.TAG, "MSG_FINAL_RESULT");
                    //parse finalResult in vo
                    final FinalResult[] finalResult = (FinalResult[]) msg.obj;
                    if (isAbandoned.get()) {
                        dbHelper.saveResultData(sdkConstant.RESULTKEY, finalResult);
                        callResultActivity();
                    } else if (finalResult != null) {
                        dbHelper.saveResultData(sdkConstant.RESULTKEY, finalResult);
                        isLastQue.set(true);
                        beforeOCounter.start();
                    }
                    break;
                //s2 connection disconnect
                case WarpCallbackMessageCode.MSG_S2_DISCONNECT:
                    LogUtils.debug(sdkConstant.TAG, "MSG_S2_DISCONNECT");
                    showMsgWithOk("Oops! An error occurred at your opponent's end. Please start another game.", sdkConstant.TAG);
                    callGoalActivity();
                    break;
                //internet not available
                case WarpCallbackMessageCode.MSG_NO_INTERNET:
                    LogUtils.debug(sdkConstant.TAG, "MSG_NO_INTERNET");
                    showMsgWithOk("Your internet connection is slow or unavailable. If this is temporary, please wait a moment or" +
                            " start a new game when the connection is better.", sdkConstant.TAG);
                    callGoalActivity();
                    break;
                case WarpCallbackMessageCode.MSG_NO_QUESTION:
                    LogUtils.debug(sdkConstant.TAG, "MSG_NO_QUESTION");
                    showNoQuestionError();
                    break;
                default:
                    break;
            }

            return false;
        }
    };
    /**
     * Initialize handler
     */
    public transient Handler handler = new Handler(warpCallBack);

    /**
     * callGoalActivity
     */
    protected synchronized void callGoalActivity() {
        LogUtils.debug(sdkConstant.TAG, "callResultActivity Start");
        try {
            //remove all listener
            String skillId = intent.getExtras().getString(sdkConstant.GOAL_INTENT);
            isGetQuestion.set(true);
            isFirstQue.set(true);
            warpClient.disconnect();
            warpClient.removeNotificationListener(warpgListener);
            warpClient.removeUpdateRequestListener(warpUListener);
            final Intent intent = new Intent(context, GoalDetailsActivity.class);
            intent.putExtra(sdkConstant.GOAL_INTENT, skillId);
            startActivity(intent);
            finish();//finishing current running activity
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "callResultActivity Stop");
    }

    /**
     * showNoQuestionError is use to show no question is available
     */
    protected void showNoQuestionError() {
        LogUtils.debug(sdkConstant.TAG, "showNoQuestionError Start");
        try {
            if (!(this).isFinishing()) {
                final ProgressDialog mProgressDialog = ProgressDialog.show(context, "", "", true);
                mProgressDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
                mProgressDialog.setContentView(R.layout.m_dialog_message_with_ok);
                final TextView tvLoading = (TextView) mProgressDialog.findViewById(R.id.tv_loading);
                tvLoading.setText("Oops! something doesn't seem right. Why don't you try again?");
                final Button tvOk = (Button) mProgressDialog.findViewById(R.id.tv_ok);
                tvOk.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(final View v) {
                        mProgressDialog.dismiss();
                        callGoalActivity();

                    }
                });
                mProgressDialog.show();
            }
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "showNoQuestionError Stop");
    }

    /**
     * disconnect user and remove listener and call ResultActivity.java
     */

    protected synchronized void callResultActivity() {
        LogUtils.debug(sdkConstant.TAG, "callResultActivity Start");
        try {
            // remove all listener
            isGetQuestion.set(true);
            isFirstQue.set(true);
            warpgListener.stopTimer();
            warpClient.disconnect();
            warpClient.removeNotificationListener(warpgListener);
            warpClient.removeUpdateRequestListener(warpUListener);
            dbHelper.saveSummeryData(sdkConstant.SUMMERYKEY, summary);
            final SharedPreferences.Editor prefsEditor = prefs.edit();
            prefsEditor.putBoolean(sdkConstant.PREF_RESULT, true);
            prefsEditor.apply();
            final Intent intentRes = new Intent(context, ResultActivity.class);
            intentRes.putExtra(sdkConstant.GOAL_INTENT, intent.getExtras().getString(sdkConstant.GOAL_INTENT));
            startActivity(intentRes);
            finish();//finishing current running activity
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "callResultActivity Stop");
    }

    /**
     * show opponent answer and correct answer
     *
     * @param opponentTime
     * @param ponits
     * @param myPoint
     */

    private synchronized void changeOptionBackGround(final String userAnswer, final String correctAnswer, final int myPoint,
                                                     final int ponits, final int opponentTime) {
        LogUtils.debug(sdkConstant.TAG, "changeOptionBackGround Start");
        try {
            int oppAnsIndex = 0;
            int correctAnsIndex;
            //receive answer in not null and no answer
            if (!s2Constant.NO_ANSWER.equals(userAnswer) && userAnswer != null) {
                //opponent answer is not null and show in orange color
                final String[] userAnswerArray = userAnswer.split("_");
                final int userAnswerIndex = Integer.parseInt(userAnswerArray[1]);
                oppAnsIndex = userAnswerIndex;
                LogUtils.debug(sdkConstant.TAG, "opponet answer is:" + userAnswerIndex);
                optionImage[userAnswerIndex - 1].setBackgroundResource(R.drawable.m_shape_orange);
                optionButton[userAnswerIndex - 1].setBackgroundResource(R.drawable.m_shape_orange);
                optionButton[userAnswerIndex - 1].setTextColor(Color.WHITE);
            }
            //show question correct answer green color
            final String[] ansArray = correctAnswer.split("_");
            final int ansIndex = Integer.parseInt(ansArray[1]);
            correctAnsIndex = ansIndex;
            optionImage[ansIndex - 1].setBackgroundResource(R.drawable.m_shape_green);
            optionButton[ansIndex - 1].setBackgroundResource(R.drawable.m_shape_green);
            optionButton[ansIndex - 1].setTextColor(Color.WHITE);
            final ArrayList<UserOption> option = new ArrayList<UserOption>();
            for (int i = 0; i < 4; i++) {
                final UserOption ops = getOption();
                ops.setFlag(s2Constant.NO_ANSWER);
                if (oppAnsIndex > 0 && oppAnsIndex - 1 == i) {
                    LogUtils.debug(sdkConstant.TAG, "opponet answer is:" + oppAnsIndex);
                    ops.setFlag(s2Constant.OPP_ANSWER);
                }
                if (myAnsIndex > 0 && myAnsIndex - 1 == i) {
                    LogUtils.debug(sdkConstant.TAG, "user answer is:" + myAnsIndex);
                    ops.setFlag(s2Constant.USER_ANSWER);
                }
                if (correctAnsIndex > 0 && correctAnsIndex - 1 == i) {
                    LogUtils.debug(sdkConstant.TAG, "correct answer is:" + correctAnsIndex);
                    ops.setFlag(s2Constant.CORRECT_ANSWER);
                }
                ops.setSeq(apiQuestion.getQuestionWrapper().getQuestion().options[i].getSeq());
                ops.setValue(apiQuestion.getQuestionWrapper().getQuestion().options[i].getValue());
                option.add(ops);
            }
            final UserQuestionVO userQuestionVO = new UserQuestionVO();
            userQuestionVO.setQuestion(apiQuestion.getQuestionWrapper().getQuestion().getQuestionString());
            userQuestionVO.setQuestionNo(apiQuestion.getQuestionWrapper().getQuestionNumber());
            userQuestionVO.setPlayer1Score(myPoint);
            userQuestionVO.setPlayer2Score(ponits);
            userQuestionVO.setPlayer1Time(Integer.parseInt(String.valueOf(responseTime)));
            userQuestionVO.setPlayer2Time(opponentTime);
            userQuestionVO.setOptions(option);
            userQuestionVO.setPlayerCLevel(goal.getcLevel().toLowerCase(Locale.getDefault()));
            userQuestionVO.setPlayerCSubLevel(goal.getcSubLevel().toLowerCase(Locale.getDefault()));
            userQuestionVO.setGoalId(goal.getSubSkillId());
            summary.add(userQuestionVO);
            LogUtils.debug(sdkConstant.TAG, "correct  answer is:" + ansIndex);
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "changeOptionBackGround Stop");
    }

    /**
     * return obj
     *
     * @return
     */
    private UserOption getOption() {
        return new UserOption();

    }

    /**
     * show opponent taken time
     */
    private synchronized void displayOpponenRing(final int opponentCount) {
        LogUtils.debug(sdkConstant.TAG, "displayOpponenRing start");
        //Opponent take time
        try {
            LogUtils.debug(sdkConstant.TAG, "Opponent take time:" + opponentCount);
            for (int i = 0; i < opponentCount; i++) {
                rightWhiteRing[i].setImageResource(R.drawable.timerwave_right_a);
            }
            final int greenIndex = 10 - opponentCount;
            //Opponent left time
            LogUtils.debug(sdkConstant.TAG, "Opponent left time:" + greenIndex);
            for (int i = 0; i < greenIndex; i++) {
                rightGreenRing[i].setImageResource(R.drawable.timerwave_right_b);
            }
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "displayOpponenRing stop");
    }

    /**
     * displayOption of current question
     */
    public void displayOption(final ApiQuestion apiQuestion) {
        LogUtils.debug(sdkConstant.TAG, "displayOption stop");
        countForImage = 0;
        try {
            linearQuestion.setVisibility(View.VISIBLE);
            for (int i = 0; i < 4; i++) {
                if (apiQuestion.getQuestionWrapper().getQuestion().options[i].getValue().contains("https://")) {
                    optionButton[i].setVisibility(View.GONE);
                    optionImage[i].setVisibility(View.VISIBLE);
                    optionImage[i].setBackgroundResource(R.drawable.m_shape_black_border);
                    optionImage[i].setClickable(true);
                    Picasso.with(context).load(apiQuestion.getQuestionWrapper().getQuestion().options[i].getValue()).into(optionImage[i], new com.squareup.picasso.Callback() {
                        @Override
                        public void onSuccess() {
                            LogUtils.debug(sdkConstant.TAG, "Success");
                            countForImage++;
                            if (totalImageCount == countForImage) {
                                countDownTimer.start();
                            }
                        }

                        @Override
                        public void onError() {
                            LogUtils.debug(sdkConstant.TAG, "Error");
                            countForImage++;
                            if (totalImageCount == countForImage) {
                                countDownTimer.start();
                            }
                        }
                    });
                } else {
                    countForImage++;
                    optionButton[i].setVisibility(View.VISIBLE);
                    optionButton[i].setClickable(true);
                    optionButton[i].setBackgroundResource(R.drawable.m_shape_black_border);
                    optionButton[i].setTextColor(Color.BLACK);
                    optionImage[i].setVisibility(View.GONE);
                    optionButton[i].setText(Html.fromHtml(apiQuestion.getQuestionWrapper().getQuestion().options[i].getValue()));
                    if (countForImage >= 3) {
                        countDownTimer.start();
                    }
                }
            }

        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "displayOption stop");
    }

    /**
     * display question with options
     */

    @SuppressLint("SetTextI18n")
    protected synchronized void displayQuestionAndOption(final ApiQuestion apiQuestion, final String type) {
        LogUtils.debug(sdkConstant.TAG, "displayQuestion start");
        try {
            switch (type) {
                case "Q":
                    answerGiven.set(false);
                    linearQuestion.setVisibility(View.GONE);
                    watchImage.setImageResource(R.drawable.timer_0);
                    for (int i = 0; i < 10; i++) {
                        leftRing[i].setImageResource(R.drawable.timerwave_left_b);
                        rightWhiteRing[i].setImageResource(R.drawable.timerwave_right_b);
                    }
                    questionCount.getAndIncrement();
                    //set question number
                    txtQuestionNo.setVisibility(View.VISIBLE);
                    txtQuestion.setVisibility(View.VISIBLE);
                    final String question = apiQuestion.getQuestionWrapper().getQuestion().getQuestionString();
                    questionId = apiQuestion.getQuestionWrapper().getQuestionId();
                    final String questionNumber = apiQuestion.getQuestionWrapper().getQuestionNumber();
                    txtQuestionNo.setText("Q" + questionNumber);
                    //set question on textview
                    txtQuestion.setText(Html.fromHtml(question));
                    totalImageCount = 0;
                    Boolean optionFlag = true;
                    for (int i = 0; i < 4; i++) {
                        if (apiQuestion.getQuestionWrapper().getQuestion().options[i].getValue().contains("https://")) {
                            optionFlag = false;
                            totalImageCount++;
                        }
                    }
                    if (optionFlag) {
                        beforeOCounter.start();
                    } else {
                        displayOption(apiQuestion);
                    }
                    break;
                case "O":
                    displayOption(apiQuestion);
                    break;
                default:
                    break;
            }
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "displayQuestion stop");
    }

    /**
     * initDisplay is use to initialize UI Content and show user and opponent
     * user profile picture ,country flag and badge
     */
    private void initUI() {
        LogUtils.debug(sdkConstant.TAG, "initDisplay start");
        try {
            uiContent();
            if (player.getName() != null) {
                final String initials = sdkCommonUtils.getShortName(player.getName());
                LogUtils.debug(sdkConstant.TAG, "Player name :" + player.getName());
                tvUserLetters.setText(initials);
            }
            showImage(ivPlayerimage, tvUserLetters);
            //image not exists show user name
            LogUtils.debug(sdkConstant.TAG, "image path not exists");
            //get badge of current player
            imageName = "drawable/" + goal.getcLevel().toLowerCase(Locale.getDefault()) + "_"
                    + goal.getcSubLevel().toLowerCase(Locale.getDefault()) + "_index";
            txtUserName.setText(player.getName());
            currentPlayer = player.getId() + "-" + goal.getGoalId() + "-" + goal.getcLevelId();
            txtOppName.setText(opponentUser.getPlayerName());
            final int imageBadge = sdkCommonUtils.getImageResource(context, imageName);
            userBadge.setImageResource(imageBadge);
            //get current player country flag
            final int imageFlag = sdkCommonUtils.getCountryFlag(context, player.getCountryCode());
            userCountryFlag.setImageResource(imageFlag);
            //get badge of opponent player
            final String uriOppBadge = "drawable/" + opponentUser.getcLevel().toLowerCase(Locale.getDefault()) + "_"
                    + opponentUser.getcSubLevel().toLowerCase(Locale.getDefault()) + "_index";
            final int imageOppBadge = sdkCommonUtils.getImageResource(context, uriOppBadge);
            //get opponent player country flag
            final int imageOppFlag = sdkCommonUtils.getCountryFlag(context, opponentUser.getCountryCode());
            oppCountryFlag.setImageResource(imageOppFlag);
            // opponent in not a virtual player
            if (opponentUser.getcLevel().length() > 1 && opponentUser.getcSubLevel().length() > 1) {
                oppBadge.setImageResource(imageOppBadge);
            } else {
                oppBadge.setImageResource(imageBadge);
            }
            //show opponent player name
            if (sdkConstant.EMPTY.equalsIgnoreCase(opponentUser.getImage())) {
                final String name = sdkCommonUtils.getShortName(opponentUser.getPlayerName());
                tvOppLetters.setText(name);
            } else {
                final String name = sdkCommonUtils.getShortName(opponentUser.getPlayerName());
                tvOppLetters.setText(name);
                tvOppLetters.setVisibility(View.VISIBLE);
                Picasso.with(context).load(opponentUser.getImage()).placeholder(R.drawable.m_circle_username_white).transform(new CircleTransform()).into(ivOppimage, new com.squareup.picasso.Callback() {
                    @Override
                    public void onSuccess() {
                        tvOppLetters.setVisibility(View.INVISIBLE);
                    }

                    @Override
                    public void onError() {
                        ivOppimage.setVisibility(View.VISIBLE);
                        tvOppLetters.setVisibility(View.VISIBLE);
                    }
                });
            }
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "initDisplay stop");
    }

    /**
     * show player image
     *
     * @param ivPlayerimage
     * @param tvUserLetters
     */
    private void showImage(final ImageView ivPlayerimage, final TextView tvUserLetters) {
        try {
            imagePath = dbHelper.profileImage(player.getId());
            if (!imagePath.equalsIgnoreCase(sdkConstant.EMPTY)) {
                tvUserLetters.setVisibility(View.VISIBLE);
                Picasso.with(context).load(imagePath).
                        placeholder(R.drawable.m_circle_username_white).transform(new CircleTransform()).into(ivPlayerimage, new com.squareup.picasso.Callback() {
                    @Override
                    public void onSuccess() {
                        tvUserLetters.setVisibility(View.INVISIBLE);
                    }

                    @Override
                    public void onError() {
                        ivPlayerimage.setVisibility(View.VISIBLE);
                        tvUserLetters.setVisibility(View.VISIBLE);
                    }
                });
            }
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
    }

    /**
     * ui content
     */
    private void uiContent() {
        try {
            leftRing = new ImageView[]{leftImage1, leftImage2, leftImage3, leftImage4, leftImage5, leftImage6, leftImage7, leftImage8,
                    leftImage9, leftImage10};
            rightWhiteRing = new ImageView[]{rightImage1, rightImage2, rightImage3, rightImage4, rightImage5, rightImage6, rightImage7,
                    rightImage8, rightImage9, rightImage10};
            rightGreenRing = new ImageView[]{rightImage10, rightImage9, rightImage8, rightImage7, rightImage6, rightImage5, rightImage4,
                    rightImage3, rightImage2, rightImage1};
            optionButton = new TextView[]{btnOption1, btnOption2, btnOption3, btnOption4};
            optionImage = new ImageView[]{imgOption1, imgOption2, imgOption3, imgOption4};
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
    }

    /**
     * initWarpAndStartGame is use for initialize warpclient and start game
     */
    private void initWarpAndStartGame() {
        LogUtils.debug(sdkConstant.TAG, "initWarpAndStartGame start");
        try {
            warpClient = WarpClient.getInstance();
            warpClient.addNotificationListener(warpgListener);
            warpClient.addUpdateRequestListener(warpUListener);
            final Map<String, String> payLoad = new ConcurrentHashMap<String, String>();
            payLoad.put(s2Constant.STATUS, s2Constant.START_GAME);
            warpClient.sendUpdatePeers(s2Constant.START_GAME.getBytes());
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "initWarpAndStartGame stop");
    }

    /**
     * back button press
     */
    @Override
    public void onBackPressed() {
        LogUtils.debug(sdkConstant.TAG, "onBackPressed start");
        if (!isAbandoned.get()) {
            showExitDialog();
        }
        LogUtils.debug(sdkConstant.TAG, "onBackPressed stop");
    }


    public void onClickImg1(View view) {
        if (!answerGiven.get()) {
            answerGiven.set(true);
            myAnsIndex = 0;
            LogUtils.debug(sdkConstant.TAG, "Press option1");
            imgOption1.setBackgroundResource(R.drawable.m_shape_purpel);
            myAnsIndex = 1;
            sendAnswerToServer(s2Constant.OPTION_1);
        }
    }

    public void onClickImg2(View view) {
        if (!answerGiven.get()) {
            answerGiven.set(true);
            myAnsIndex = 0;
            LogUtils.debug(sdkConstant.TAG, "Press option2");
            imgOption2.setBackgroundResource(R.drawable.m_shape_purpel);
            myAnsIndex = 2;
            sendAnswerToServer(s2Constant.OPTION_2);
        }
    }

    public void onClickImg3(View view) {
        if (!answerGiven.get()) {
            answerGiven.set(true);
            myAnsIndex = 0;
            LogUtils.debug(sdkConstant.TAG, "Press option3");
            imgOption3.setBackgroundResource(R.drawable.m_shape_purpel);
            myAnsIndex = 3;
            sendAnswerToServer(s2Constant.OPTION_3);
        }
    }

    public void onClickImg4(View view) {
        if (!answerGiven.get()) {
            answerGiven.set(true);
            myAnsIndex = 0;
            LogUtils.debug(sdkConstant.TAG, "Press option4");
            imgOption4.setBackgroundResource(R.drawable.m_shape_purpel);
            myAnsIndex = 4;
            sendAnswerToServer(s2Constant.OPTION_4);
        }
    }

    public void onClickTxt1(View view) {
        if (!answerGiven.get()) {
            answerGiven.set(true);
            myAnsIndex = 0;
            LogUtils.debug(sdkConstant.TAG, "Press option1");
            btnOption1.setBackgroundResource(R.drawable.m_shape_purpel);
            btnOption1.setTextColor(Color.WHITE);
            myAnsIndex = 1;
            sendAnswerToServer(s2Constant.OPTION_1);
        }
    }

    public void onClickTxt2(View view) {
        if (!answerGiven.get()) {
            answerGiven.set(true);
            myAnsIndex = 0;
            LogUtils.debug(sdkConstant.TAG, "Press option2");
            btnOption2.setBackgroundResource(R.drawable.m_shape_purpel);
            btnOption2.setTextColor(Color.WHITE);
            myAnsIndex = 2;
            sendAnswerToServer(s2Constant.OPTION_2);
        }
    }

    public void onClickTxt3(View view) {
        if (!answerGiven.get()) {
            answerGiven.set(true);
            myAnsIndex = 0;
            LogUtils.debug(sdkConstant.TAG, "Press option3");
            btnOption3.setBackgroundResource(R.drawable.m_shape_purpel);
            btnOption3.setTextColor(Color.WHITE);
            myAnsIndex = 3;
            sendAnswerToServer(s2Constant.OPTION_3);
        }
    }

    public void onClickTxt4(View view) {
        if (!answerGiven.get()) {
            answerGiven.set(true);
            myAnsIndex = 0;
            LogUtils.debug(sdkConstant.TAG, "Press option4");
            btnOption4.setBackgroundResource(R.drawable.m_shape_purpel);
            btnOption4.setTextColor(Color.WHITE);
            myAnsIndex = 4;
            sendAnswerToServer(s2Constant.OPTION_4);
        }
    }

    /**
     * onClick event
     */

    public void onClick(final View view) {
        LogUtils.debug(sdkConstant.TAG, "onClick start");


        LogUtils.debug(sdkConstant.TAG, "onClick stop");
    }

    /**
     * onCreate
     */
    @Override
    protected void onCreate(final Bundle bundel) {
        super.onCreate(bundel);
        try {
            setContentView(R.layout.m_activity_game);
            context = this;
            dbHelper = SDKDBHelper.getInstance(context);
            player = dbHelper.getLogedUser();
            btnOption1 = (TextView) findViewById(R.id.btn_option_1);
            btnOption2 = (TextView) findViewById(R.id.btn_option_2);
            btnOption3 = (TextView) findViewById(R.id.btn_option_3);
            btnOption4 = (TextView) findViewById(R.id.btn_option_4);
            watchImage = (ImageView) findViewById(R.id.iv_timer);
            leftImage1 = (ImageView) findViewById(R.id.iv_left_b1);
            leftImage2 = (ImageView) findViewById(R.id.iv_left_b2);
            leftImage3 = (ImageView) findViewById(R.id.iv_left_b3);
            leftImage4 = (ImageView) findViewById(R.id.iv_left_b4);
            leftImage5 = (ImageView) findViewById(R.id.iv_left_b5);
            leftImage6 = (ImageView) findViewById(R.id.iv_left_b6);
            leftImage7 = (ImageView) findViewById(R.id.iv_left_b7);
            leftImage8 = (ImageView) findViewById(R.id.iv_left_b8);
            leftImage9 = (ImageView) findViewById(R.id.iv_left_b9);
            leftImage10 = (ImageView) findViewById(R.id.iv_left_b10);
            rightImage1 = (ImageView) findViewById(R.id.iv_right_b1);
            rightImage2 = (ImageView) findViewById(R.id.iv_right_b2);
            rightImage3 = (ImageView) findViewById(R.id.iv_right_b3);
            rightImage4 = (ImageView) findViewById(R.id.iv_right_b4);
            rightImage5 = (ImageView) findViewById(R.id.iv_right_b5);
            rightImage6 = (ImageView) findViewById(R.id.iv_right_b6);
            rightImage7 = (ImageView) findViewById(R.id.iv_right_b7);
            rightImage8 = (ImageView) findViewById(R.id.iv_right_b8);
            rightImage9 = (ImageView) findViewById(R.id.iv_right_b9);
            rightImage10 = (ImageView) findViewById(R.id.iv_right_b10);
            txtQuestionNo = (TextView) findViewById(R.id.tv_question_number);
            txtQuestion = (TextView) findViewById(R.id.tv_question);
            playerSkill = (TextView) findViewById(R.id.tv_player_skill);
            linearQuestion = (LinearLayout) findViewById(R.id.li_question_layout);
            txtUserName = (TextView) findViewById(R.id.tv_local_user);
            txtOppName = (TextView) findViewById(R.id.tv_opponent_user);
            tvUserLetters = (TextView) findViewById(R.id.tvUserLetter);
            ivPlayerimage = (ImageView) findViewById(R.id.ibUserImage);
            tvOppLetters = (TextView) findViewById(R.id.tvOppLetter);
            ivOppimage = (ImageView) findViewById(R.id.iv_opponent_dp);
            userBadge = (ImageView) findViewById(R.id.iv_local_user_badge);
            userCountryFlag = (ImageView) findViewById(R.id.iv_local_user_flag);
            imgOption1 = (ImageView) findViewById(R.id.img_option_1);
            imgOption2 = (ImageView) findViewById(R.id.img_option_2);
            imgOption3 = (ImageView) findViewById(R.id.img_option_3);
            imgOption4 = (ImageView) findViewById(R.id.img_option_4);
            oppBadge = (ImageView) findViewById(R.id.iv_opponent_user_badge);
            oppCountryFlag = (ImageView) findViewById(R.id.iv_opponent_user_flag);
            intent = getIntent();
            String skillId = intent.getExtras().getString(sdkConstant.GOAL_INTENT);
            goal = dbHelper.getGoal(skillId);
            myAnsIndex = 0;
            intervel = 1000;
            try {
                if (null != goal.getTick() && !sdkConstant.EMPTY.equalsIgnoreCase(goal.getTick())) {
                    intervel = Integer.parseInt(goal.getTick());
                }
            } catch (Exception e) {
                intervel = 1000;
            }
            max = intervel / 100;
            summary = new ArrayList<UserQuestionVO>();
            opponentUser = dbHelper.getOpponentData(sdkConstant.OPPONENTKEY);
            warpgListener = new WarpGameNotifyListener(handler, this);
            warpUListener = new WarpUpdateRequestListener();
            beforeOCounter = new BEBeforeOptionCountDownTimer(OPTIONTIME, INTERVEL);
            beforeQCounter = new BEBeforeQuestionCountDownTimer(QUESTIONTIME, INTERVEL);
            countDownTimer = new BEGameCountDownTimer(Long.valueOf("10") * Long.valueOf(intervel), Long.valueOf(intervel));
            if (null != goal.getSubskillType() && sdkConstant.CONTEST.equalsIgnoreCase(goal.getSubskillType())) {
                userBadge.setVisibility(View.GONE);
                oppBadge.setVisibility(View.GONE);
            }
            playerSkill.setText(goal.getSubSkill());
            initWarpAndStartGame();
            initUI();
            final SharedPreferences.Editor prefsEditor = prefs.edit();
            prefsEditor.putString(sdkConstant.PREF_ACCHIVEMENT, sdkConstant.EMPTY);
            prefsEditor.apply();
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
    }


    /**
     * onDestroy
     */
    @Override
    protected void onDestroy() {
        LogUtils.debug(sdkConstant.TAG, "Game activity On Destroy");
        try {
            isGetQuestion.set(true);
            isFirstQue.set(true);
            /**
             * internet is present
             */
            if (isInternetAvailable()) {
                warpClient.sendUpdatePeers(WarpResponseCode.ABANDONED_CODE.getBytes());
            }
            warpClient.disconnect();
            warpClient.removeNotificationListener(warpgListener);
            warpClient.removeUpdateRequestListener(warpUListener);
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        super.onDestroy();
    }

    /**
     * sendAnswerToServer is use to send current question answer to server with
     * taken time
     */
    private synchronized void sendAnswerToServer(final String option) {
        LogUtils.debug(sdkConstant.TAG, "sendAnswerToServer start");
        try {
            isGetQuestion.set(true);
            answerGiven.set(true);
            final Map<String, String> payLoad = new ConcurrentHashMap<String, String>();
            payLoad.put(s2Constant.QUESTION_ID, questionId);
            payLoad.put(s2Constant.ANSWER, option);
            payLoad.put(s2Constant.TIME, String.valueOf(responseTime));
            payLoad.put(s2Constant.USERNAME, currentPlayer);
            LogUtils.debug(sdkConstant.TAG, "User give question answer:" + payLoad.toString());
            //Cancel Game CountDown Timer and Start Notify Listener Timer
            warpgListener.startTimer();
            warpClient.sendUpdatePeers(AbstractBEJsonParser.convertToJson(payLoad).getBytes());
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "sendAnswerToServer stop");
    }

    /**
     * updateAnswerAndScore is use to show players score and given answer and
     * time
     */
    protected synchronized void showAnswerAndScore(final AnswerTimeResponse[] ansResponse) {
        LogUtils.debug(sdkConstant.TAG, "updateAnswerAndScore start");
        try {
            countDownTimer.cancel();
            int myPoint = 0;
            int opponentTime = 0;
            int virtualIndex = 0;
            final TextView txtUserScore = (TextView) findViewById(R.id.tv_local_score);
            final TextView txtOppScore = (TextView) findViewById(R.id.tv_opponent_score);
            for (int i = 0; i < ansResponse.length; i++) {
                //if player is local player
                if (currentPlayer.equals(ansResponse[i].userName)) {
                    LogUtils.debug(sdkConstant.TAG, "Current player point:" + ansResponse[i].ponits);
                    myPoint = ansResponse[i].ponits;
                    txtUserScore.setText(String.valueOf(ansResponse[i].ponits));
                } else {
                    /**
                     * opponent player
                     */
                    virtualIndex = i;
                    txtOppScore.setText(String.valueOf(ansResponse[i].ponits));
                    LogUtils.debug(sdkConstant.TAG, "Opponent player point:" + ansResponse[i].ponits);
                    opponentTime = Integer.parseInt(ansResponse[i].time);
                    LogUtils.debug(sdkConstant.TAG, "Opponent  player time:" + opponentTime);
                    displayOpponenRing(opponentTime);
                }
                if (i == ansResponse.length - 1) {
                    changeOptionBackGround(ansResponse[virtualIndex].userAnswer, ansResponse[virtualIndex].correctAnswer, myPoint,
                            ansResponse[virtualIndex].ponits, opponentTime);
                }
            }
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "updateAnswerAndScore stop");
    }

    /**
     * on press back button of device
     */
    private void showExitDialog() {
        LogUtils.debug(sdkConstant.TAG, "showExitDialog start");
        try {
            if (!((Activity) context).isFinishing()) {
                final ProgressDialog progressDialog = ProgressDialog.show(context, "", "", true);
                progressDialog.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
                progressDialog.setContentView(R.layout.m_dialog_message_restart);
                progressDialog.setCancelable(true);
                final TextView tvLoading = (TextView) progressDialog.findViewById(R.id.tv_loading);
                tvLoading.setText("Are you sure you wish to abandon the game?");
                final Button tvYes = (Button) progressDialog.findViewById(R.id.tv_yes);
                tvYes.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(final View v) {
                        progressDialog.dismiss();
                        if (isInternetAvailable()) {
                            // cancel timers
                            countDownTimer.cancel();
                            beforeOCounter.cancel();
                            beforeQCounter.cancel();
                            isGetQuestion.set(true);
                            isFirstQue.set(true);
                            isAbandoned.set(true);
                            warpgListener.stopTimer();
                            warpClient.sendUpdatePeers(WarpResponseCode.ABANDONED_CODE.getBytes());
                        } else {
                            callGoalActivity();
                        }
                    }
                });
                final Button tvNo = (Button) progressDialog.findViewById(R.id.tv_no);
                tvNo.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(final View v) {
                        progressDialog.dismiss();
                    }
                });
                progressDialog.show();
            }
        } catch (Exception e) {
            LogUtils.error(sdkConstant.TAG, "Exception", e);
        }
        LogUtils.debug(sdkConstant.TAG, "showExitDialog stop");
    }


}
